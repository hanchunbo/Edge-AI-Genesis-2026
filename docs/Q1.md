
---

# 🗓 2026 年 Q1 突击执行手册：高性能 C++ 与工程化基础

**阶段目标**：重塑底层思维，对齐大厂 C++ 开发标准，解决 AI 预处理环节的性能瓶颈。

---

## 第一阶段：现代 C++ 核心内存与性能优化 (W1 - W5)

### **W1：内存安全、RAII 机制与智能指针**

* **学习目的 (Why)**：AI 推理程序常驻运行，内存泄漏是 OOM 崩溃的元凶。掌握 RAII 是从“写逻辑”到“写系统”的转变。
* **核心范围 (Scope)**：智能指针（`unique`/`shared`/`weak`）底层原理、所有权转移逻辑、析构函数闭环、`weak_ptr` 解决循环引用。
* **实战作业 (Assignment)**：编写 `SafeTensorBuffer` 类管理模拟显存/内存块。要求：构造函数分配资源，禁用拷贝构造，支持移动语义，并在抛出异常时验证资源 100% 自动回收。
* **成功指标 (Metrics)**：`Valgrind` 检测报告显示 "0 bytes leaked"；能准确说出 `shared_ptr` 引用计数原子操作对高频推理的性能损耗。

### **W2：零拷贝思想：移动语义与右值引用**

* **学习目的 (Why)**：在边缘端（如 3060 或 VPS）处理 4K/8K 图像时，内存拷贝是巨大的性能浪费。
* **核心范围 (Scope)**：右值引用、`std::move` 的本质、移动构造函数与移动赋值运算符、完美转发 `std::forward`。
* **实战作业 (Assignment)**：编写性能 Benchmark 脚本，对比将 1000 帧 4K 图像（`CustomImage` 类）存入 `std::vector` 时，“深度拷贝”与“移动语义”的耗时差异。
* **成功指标 (Metrics)**：移动操作耗时应接近 0ms 且不随数据量增加而增长；通过 `static_assert` 在编译期验证类型的可移动性。

### **W3：C++17 跨平台实战特性与视图优化**

* **学习目的 (Why)**：规范模型文件管理逻辑，利用视图技术减少不必要的字符串内存分配。
* **核心范围 (Scope)**：`std::filesystem` 跨平台路径管理、`std::optional` 优雅处理异常返回、`std::string_view` 视图优化、结构化绑定。
* **实战作业 (Assignment)**：编写“AI 模型自动扫描器”。要求：递归扫描 `/models` 目录，筛选 `.onnx` 文件，使用 `optional` 返回包含文件名与大小的元数据，解析逻辑强制使用 `string_view`。
* **成功指标 (Metrics)**：核心解析代码无冗余的 `std::string` 临时对象产生；代码在 Linux/Windows 下一键编译且路径处理逻辑一致。

### **W4：并发编程基础：多线程与任务同步**

* **学习目的 (Why)**：利用多核架构加速预处理。理解“预处理-推理-后处理”流水线的并行逻辑。
* **核心范围 (Scope)**：`std::thread` 生命周期管理、`std::mutex` 与 `std::lock_guard`、条件变量 `condition_variable`。
* **实战作业 (Assignment)**：实现“生产者-消费者”图像处理原型：线程 A 模拟采集入队，线程 B 模拟预处理出队。实现一个线程安全的循环队列（Thread-safe Queue）。
* **成功指标 (Metrics)**：系统在高并发下不出现死锁（Deadlock）；测算处理延迟，验证 B 线程能及时响应 A 线程的通知。

### **W5：高性能并发进阶：通用线程池架构**

* **学习目的 (Why)**：频繁创建/销毁线程开销巨大，线程池是多路视频流 AI 推理的工业标配。
* **核心范围 (Scope)**：基于 `std::queue` 的任务队列、使用 `std::future` 和 `std::packaged_task` 实现异步结果获取、泛型任务提交。
* **实战作业 (Assignment)**：手写一个支持泛型任务提交的 `ThreadPool` 类。支持向池中提交任意 Lambda 函数，并获取异步执行结果。
* **成功指标 (Metrics)**：成功并行执行 100 个模拟图像旋转任务；线程池在任务空闲时处于低功耗挂起状态。

---

## 第二阶段：Linux 系统工程与高性能构建 (W6 - W8)

### **W6：Linux 高性能 I/O：文件映射 mmap**

* **学习目的 (Why)**：加载数 GB 模型权重时，`mmap` 是零拷贝加载、提升启动速度的关键。
* **核心范围 (Scope)**：`mmap` 原理、系统调用 `open`/`read` 与标准库缓冲对比、内存页对齐基础。
* **实战作业 (Assignment)**：对比实验：编写程序读取 500MB 权重文件，记录并对比使用 `fstream` 与 `mmap` 将文件映射到内存的加载耗时。
* **成功指标 (Metrics)**：`mmap` 版加载速度明显优于传统 I/O；能解释内存映射在进程间通信（IPC）中的潜在应用。

### **W7：现代 CMake 工程构建 (I)：架构与权限**

* **学习目的 (Why)**：规范的构建系统是项目协作的基础，对齐一线大厂交付标准。
* **核心范围 (Scope)**：Target-based CMake 模式、`INTERFACE`/`PRIVATE`/`PUBLIC` 权限、多模块子目录管理。
* **实战作业 (Assignment)**：重构之前 6 周的代码，搭建标准多模块工程（`lib`、`app`、`tests`），实现模块化编译。
* **成功指标 (Metrics)**：库文件导出正确，外部应用只需 `target_link_libraries` 即可自动包含头文件路径。

### **W8：现代 CMake (II) 与自动化单元测试**

* **学习目的 (Why)**：保证转型过程中的代码质量，实现自动化回归。
* **核心范围 (Scope)**：使用 `FetchContent` 自动化管理第三方库（GTest）、自动化测试脚本编写、代码覆盖率统计。
* **实战作业 (Assignment)**：在工程中集成 `GoogleTest`，为 `SafeTensorBuffer` 和 `ThreadPool` 编写覆盖率 >80% 的单元测试用例。
* **成功指标 (Metrics)**：执行 `ctest` 全部通过；输出覆盖率报告且核心逻辑无盲区。

---

## 第三阶段：OpenCV 底层实战与性能调优 (W9 - W13)

### **W9：OpenCV 高级：像素级指针操作与内存布局**

* **学习目的 (Why)**：深入理解 `cv::Mat` 内存排布，编写比原生函数更快的定制化算子。
* **核心范围 (Scope)**：`cv::Mat` 内存对齐（step/stride）、行指针 `.ptr<T>` 操作、连续矩阵判断与优化。
* **实战作业 (Assignment)**：手写高性能 C++ 循环实现 BGR 转 Gray。要求：禁止使用 `cvtColor`，直接操作原始指针，对比其与原生函数的耗时。
* **成功指标 (Metrics)**：手写版性能不低于原生版（或能解释差距原因）；掌握内存对齐导致的位宽差异处理。

### **W10：图像插值与几何变换底层原理**

* **学习目的 (Why)**：模型预处理中的 Resize 直接影响推理精度。掌握插值数学原理是优化算子的前提。
* **核心范围 (Scope)**：最近邻插值与双线性插值数学公式、仿射变换矩阵推导、图像对齐（Padding/Letterbox）。
* **实战作业 (Assignment)**：手写实现 `Resize` 算子。要求：输入 1080P，输出 640x640，且必须保持比例，不足部分实现手动 Padding 补黑边。
* **成功指标 (Metrics)**：输出图像像素与 OpenCV `resize` 结果一致；能解释插值算法对模型特征提取的影响。

### **W11：性能调优工具链：定位瓶颈与 Bug**

* **学习目的 (Why)**：解决 C++ 开发中最棘手的 Segfault、死锁和性能瓶颈。
* **核心范围 (Scope)**：GDB 堆栈追踪、Valgrind 内存检测、Perf 分析热点函数占用的 CPU 周期。
* **实战作业 (Assignment)**：修复一个包含“故意漏洞”的项目：包含内存泄漏、一个偶发性死锁和一段耗时严重的冗余循环。
* **成功指标 (Metrics)**：所有 Bug 被精准定位并修复；使用 Perf 输出优化前后的热点图对比。

### **W12：Q1 知识闭环与技术复盘**

* **核心任务**：梳理前 11 周笔记，完善 GitHub 仓库文档，建立“技术决策 Trade-offs”记录。
* **管理视角 (MEM)**：利用 MEM 所学的进度管理工具（甘特图），复盘 Q1 执行情况，评估后续风险。

### **W13：【Q1 阶段性项目】高性能多线程图像预处理引擎**

* **任务描述**：综合 Q1 所有知识。实现一个基于线程池的图像处理系统。
* **要求**：
1. 使用 CMake 构建，集成 GTest。
2. 支持多路视频/图像流并发处理。
3. 核心算子（Resize/Gray）采用 W9-W10 中手写的优化版本。
4. 输出详尽的各模块耗时报告（利用 Q2 预热的数据分析思维）。


* **成功指标**：产出一套可复用的 C++ 部署框架原型，作为 2026 简历的首个硬核项目。

---

**给 Member A & B 的执行建议：**

* **周日 Review 机制**：建议每周日晚 20:00 进行 PR (Pull Request) 评审。互相检查代码中的内存管理是否符合 W1 标准，性能是否有冗余。
* **文档同步**：每完成一个作业，请将对应的性能数据（耗时、内存占用）存入 `docs/benchmarks` 文件夹。